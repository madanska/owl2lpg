# OWL 2 Web Ontology Language Mapping to Labelled Property Graphs



## Translation of Axioms without Annotations

The table below presents the operator T that maps an OWL 2 ontology *O* into a LPG graph *T(O)*, provided that no axiom in *O* is annotated. The mapping is defined recursively; that is, the mapping of a construct often depends on the mappings of its subconstructs, but in a slightly unusual way: if the mapping of a construct refers to the mapping of a subconstruct, then the graph generated by the recursive invocation of the mapping on the subconstruct are added to the graph under construction, and the *main node* (denoted by a **bold-faced** variable) of the mapping of the subconstruct is used in place of the recursive invocation itself.

The following conventions are used in this section to denote different parts of OWL 2 ontologies:

* `OP` denotes an object property;
* `OPE` denotes an object property expression;
* `DP` denotes a data property;
* `DPE` denotes a data property expression;
* `AP` denotes an annotation property;
* `C` denotes a class;
* `CE` denotes a class expression;
* `DT` denotes a datatype;
* `DR` denotes a data range;
* `U` denotes an IRI;
* `F` denotes a constraining facet;
* `a` denotes an individual (named or anonymous);
* `*:a` denotes a named individual;
* `_:a` denotes an anonymous individual;
* `lt` denotes a literal;
* `as` denotes an annotation source; and
* `av` denotes an annotation value.

In this section, T(`SEQ` `y1` ... `yn`) denotes the translation of a sequence of objects from the structural specification into a linked-list graph.



**Table 1**: Translation to LPG

| Element *E* of the Structural Specification                  | Graph Generated in an Invocation of *T(E)*                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `y1` ... `yn`                                                | ***nodes*** = { n \| T(`y1`) ... T(`yn`) }                   |
| `SEQ` `y1` ... `yn`                                          | **node** = T(`y1`)<br />EDGE( *node*, T(`SEQ` `y2` ... `yn`), "next", {} ) |
| Ontology(<br />   `ontologyIRI`<br />   [`versionIRI`]<br />   Import(`ontologyIRI1`) ... Import(`ontologyIRIk`)<br />   `annotation1` ... `annotationm`<br />   `axiom1` ... `axiomn`) | ***ontologyNode*** = T(`ontologyIRI`)<br />*importOntologyNodes* = T(`ontologyIRI1` ... `ontologyIRIk`)<br />*axiomAnnotationNodes* = TANN(`annotation1` ... `annotationm`)<br />*axiomNodes* = T(`axiom1` ... `axiomn`)<br />EDGES( *ontologyNode*, <br />              *importOntologyNodes*, <br />             "importOntology", {} )<br />EDGES( *ontologyNode*, <br />              *axiomAnnotationNodes*, <br />              "axiomAnnotation", {} )<br />EDGES( *ontologyNode*, <br />              *axiomNodes*, <br />              "axiom", {} ) |
| `C`                                                          | ***classNode*** = <br />    NODE( ["Class", "ClassExpression", "Entity"], {} )<br />*iriNode* = T(IRI(`C`))<br />EDGE( *classNode*, <br />            *iriNode*, <br />            "entityIri", {} ) |
| `DT`                                                         | ***datatypeNode*** = <br />   NODE( ["Datatype", "Entity"], {} )<br />*iriNode* = T(IRI(`DT`))<br />EDGE( *datatypeNode*, <br />            *iriNode*, <br />            "entityIri", {} ) |
| `OP`                                                         | ***objectPropertNode*** = <br />   NODE( ["ObjectProperty", "ObjectPropertyExpression", "Entity"], {} )<br />*iriNode* = T(IRI(`OP`))<br />EDGE( *objectPropertyNode*, <br />            *iriNode*, <br />            "entityIri", {} ) |
| `DP`                                                         | ***dataPropertyNode*** = <br />    NODE( ["DataProperty", "DataPropertyExpression", "Entity"], {} )<br />iriNode = T(IRI(`DP`))<br />EDGE( *dataPropertyNode*, <br />            *iriNode*, <br />            "entityIri", {} ) |
| `AP`                                                         | ***annotationPropertyNode*** = <br />   NODE( ["AnnotationProperty", "Entity"], {} )<br />*iriNode* = T(IRI(`AP`))<br />EDGE( *annotationProperty*, <br />            *iriNode*, <br />            "entityIri", {} ) |
| `*:a`                                                        | ***namedIndividualNode*** = <br />   NODE( ["NamedIndividual", "Individual", "Entity"], {} )<br />*iriNode* = T(IRI(`*:a`))<br />EDGE( *namedIndividualNode*, <br />            *iriNode*, <br />            "entityIri", {} ) |
| `_:a`                                                        | ***anonymousIndividualNode*** = <br />    NODE( ["AnonymousIndividual"], { nodeID=`blank_node_label` } ) |
| `U`                                                          | ***iriNode*** = NODE( ["IRI"], { value=`U` } )               |
| `F lt`                                                       | ***restrictionNode*** = NODE( ["FacetRestriction"], {} )<br />*constrainingFacetNode* = T(`U`)<br />*literalNode* = T(`lt`)<br />EDGE( *restrictionNode*, <br />            *constraintFacetNode*, <br />            "constrainingFacet", {} )<br />EDGE( *restrictionNode*, <br />            *literalNode*, <br />            "restrictionValue", {} ) |
| "abc@"^^*rdf:PlainLiteral*                                   | ***literalNode*** = NODE( ["Literal"], { lexicalForm="abc" } )<br />*datatypeNode* = T(rdf:PlainLiteral)<br />*languageTagNode* = NODE( ["LanguageTag"], { language="" } )<br />EDGE( *literalNode*, <br />            *datatypeNode*, <br />            "datatype", {} )<br />EDGE( *literalNode*, <br />            *languageTagNode*, <br />            "languageTag", {} ) |
| "abc@`langTag`"^^*rdf:PlainLiteral*                          | ***literalNode*** = NODE( ["Literal"], { lexicalForm="abc" } )<br />*datatypeNode* = T(rdf:PlainLiteral)<br />*languageTagNode* = NODE( ["LanguageTag"], { language=`langTag` } )<br />EDGE( *literalNode*, <br />            *datatypeNode*, <br />            "datatype", {} )<br />EDGE( *literalNode*, <br />            *languageTagNode*,<br />            "languageTag", {} ) |
| `lt` { where `lt` is a literal of `datatype`<br /> other than *rdf:PlainLiteral* } | ***literalNode*** = NODE( ["Literal"], { lexicalForm="abc" } )<br />*datatypeNode* = T(Datatype(`datatype`))<br />EDGE( *literalNode*, <br />            *datatypeNode*, <br />            "datatype", {} ) |
| Declaration(Datatype(`DT`))                                  | ***declarationAxiomNode*** = NODE( ["Declaration"m "Axiom"], {} )<br />*datatypeNode* = T(`DT`)<br />EDGE( *declarationAxiomNode*, <br />            *datatypeNode*, <br />            "entity", {} ) |
| Declaration(Class(`C`))                                      | ***declarationAxiomNode*** = NODE( ["Declaration", "Axiom"], {} )<br />*classNode* = T(`C`)<br />EDGE( *declarationAxiomNode*, <br />            *classNode*, <br />            "entity", {} ) |
| Declaration(ObjectProperty(`OP`))                            | ***declarationAxiomNode*** = NODE( ["Declaration", "Axiom"], {} )<br />*objectPropertyNode* = T(`OP`)<br />EDGE( *declarationAxiomNode*, <br />            *objectPropertyNode*, <br />            "entity", {} ) |
| Declaration(DataProperty(`DP`))                              | **declarationAxiomNode** = NODE( ["Declaration", "Axiom"], {} )<br />dataPropertyNode = T(`DP`)<br />EDGE( declarationAxiomNode, <br />            dataPropertyNode, <br />            "entity", {} ) |
| Declaration(AnnotationProperty(`AP`))                        | ***declarationAxiomNode*** = NODE( ["Declaration", "Axiom"], {} )<br />*annotationPropertyNode* = T(`AP`)<br />EDGE( *declarationAxiomNode*, <br />            *annotationPropertyNode*, <br />            "entity", {} ) |
| Declaration(NamedIndividual(`*:a`))                          | ***declarationAxiomNode*** = NODE( ["Declaration", "Axiom"], {} )<br />*namedIndividualNode* = T(`*:a`)<br />EDGE( *declarationAxiomNode*, <br />            *namedIndividualNode*, <br />            "entity", {} ) |
| ObjectInverseOf(`OP`)                                        | ***inverseObjectPropertyNode*** = <br />   NODE( ["ObjectInverseOf", "ObjectPropertyExpression"], {} )<br />*objectPropertyNode* = T(`OP`)<br />EDGE( *inverseObjectPropertyNode*, <br />            *objectPropertyNode*, <br />            "objectProperty", {} ) |
| DataIntersectionOf(`DR1` ... `DRn`)                          | ***intersectionOfDataRangesNode*** = <br />   NODE( ["DataIntersectionOf", "DataRange"], {} )<br />*dataRangeNodes* = T(`DR1` ... `DRn`)<br />EDGES( *intersectionOfDataRangesNode*, <br />              *dataRangeNodes*, <br />              "dataRange", {} ) |
| DataUnionOf(`DR1` ... `DRn`)                                 | ***unionOfDataRangesNode*** = <br />   NODE( ["DataUnionOf", "DataRange"], {} )<br />*dataRangeNodes* = T(`DR1` ... `DRn`)<br />EDGES( *unionOfDataRangesNode*, <br />              *dataRangeNodes*, <br />              "dataRange", {} ) |
| DataComplementOf(`DR`)                                       | ***complementOfDataRangeNode*** = <br />   NODE( ["DataComplementOf", "DataRange"], {} )<br />*dataRangeNode* = T(`DR`)<br />EDGES( *unionOfDataRangesNode*, <br />              *dataRangeNode*, <br />              "dataRange", {} ) |
| DataOneOf(`lt1` ... `ltn`)                                   | **enumerationOfLiteralsNode** = <br />   NODE( ["DataOneOf", "DataRange"], {} )<br />literalNodes = T(`lt1` ... `ltn`)<br />EDGES( enumerationOfLiteralsNode, <br />              literalNodes, <br />              "dataRange", {} ) |
| DatatypeRestriction(<br />   `DT` `F1 lt1` ... `Fn ltn`)     | ***datatypeRestrictionsNode*** = <br />   NODE( ["DatatypeRestriction", "DataRange"], {} )<br />*datatypeNode* = T(`DT`)<br />*restrictionNodes* = T(`F1 lt1`  ... `Fn ltn`)<br />EDGE( *datatypeRestrictionsNode*, <br />            *datatypeNode*,<br />            "datatype", {} )<br />EDGES( *datatypeRestrictionsNode*,<br />              *restrictionNodes*, <br />              "restriction", {} ) |
| ObjectIntersectionOf(`CE1` ... `CEn`)                        | ***intersectionOfClassExpressionsNode*** = <br />   NODE( ["ObjectIntersectionOf", "ClassExpression"], {} )<br />*classExpressionNodes* = T(`CE1` ... `CEn`)<br />EDGES( *intersectionOfClassExpressionsNode*, <br />              *classExpressionNodes*, <br />              "classExpression", {} ) |
| ObjectUnionOf(`CE1` ... `CEn`)                               | ***unionOfClassExpressionsNode*** = <br />   NODE( ["ObjectUnionOf", "ClassExpression"], {} )<br />*classExpressionNodes* = T(`CE1` ... `CEn`)<br />EDGES( *unionOfClassExpressionsNode*, <br />              *classExpressionNodes*, <br />              "classExpression", {} ) |
| ObjectComplementOf(`CE`)                                     | ***complementOfClassExpressionNode*** = <br />   NODE( ["ObjectComplementOf", "ClassExpression"], {} )<br />*classExpressionNode* = T(`CE`)<br />EDGE( *complementOfClassExpressionNode*, <br />            *classExpressionNode*, <br />            "classExpression", {} ) |
| ObjectOneOf(`a1` ... `an`)                                   | ***enumerationOfIndividualsNode*** = <br />   NODE( ["ObjectOneOf", "ClassExpression"], {} )<br />*individualNodes* = T(`a1` ... `an`)<br />EDGES( *enumerationOfIndividualsNode*, <br />              *individualNodes*, <br />              "individual", {} ) |
| ObjectSomeValuesFrom(`OPE` `CE`)                             | ***existentialQuantifierNode*** = <br />   NODE( ["ObjectSomeValuesFrom", "ClassExpression"], {} )<br />*objectPropertyNode* = T(`OPE`)<br />*classExpressionNode* = T(`CE`)<br />EDGE( *existentialQuantifierNode*, <br />            *objectPropertyNode*, <br />            "objectPropertyExpression", {} )<br />EDGE( *existentialQuantifierNode*, <br />            *classExpressionNode*, <br />            "classExpression", {} ) |
| ObjectAllValuesFrom(`OPE` `CE`)                              | ***universalQuantifierNode*** = <br />   NODE( ["ObjectAllValuesFrom", "ClassExpression"], {} )<br />*objectPropertyNode* = T(`OPE`)<br />*classExpressionNode* = T(`CE`)<br />EDGE( *universalQuantifierNode*, <br />            *objectPropertyNode*, <br />            "objectPropertyExpression", {} )<br />EDGE( *universalQuantifierNode*, <br />            *classExpressionNode*, <br />            "classExpression", {} ) |
| ObjectHasValue(`OPE` `a`)                                    | ***individualValueRestrictionNode*** = <br />   NODE( ["ObjectHasValue", "ClassExpression"], {} )<br />*objectPropertyNode* = T(`OPE`)<br />*individualNode* = T(`a`)<br />EDGE( *individualValueRestrictionNode*, <br />            *objectPropertyNode*, <br />            "objectPropertyExpression", {} )<br />EDGE( *individualValueRestrictionNode*, <br />            *individualNode*, <br />            "individual", {} ) |
| ObjectHasSelf(`OPE`)                                         | ***selfRestrictionNode*** = <br />   NODE( ["ObjectHasSelf", "ClassExpression"], {} )<br />*objectPropertyNode* = T(`OPE`)<br />EDGE( *selfRestrictionNode*, <br />            *objectPropertyNode*, <br />            "objectPropertyExpression", {} ) |
| ObjectMinCardinality(`n` `OPE`)                              | ***minimumCardinalityNode*** = <br />    NODE( ["ObjectMinCardinality", "ClassExpression"], { cardinality=`n` } )<br />*objectPropertyNode* = T(`OPE`)<br />EDGE( *minimumCardinalityNode*, <br />            *objectPropertyNode*, <br />            "objectPropertyExpression", {} ) |
| ObjectMinCardinality(`n` `OPE` `CE`)                         | ***minimumCardinalityNode*** = <br />   NODE( ["ObjectMinCardinality", "ClassExpression"], { cardinality=`n` } )<br />*objectPropertyNode* = T(`OPE`)<br />*classExpressionNode* = T(`CE`)<br />EDGE( *minimumCardinalityNode*, <br />            *objectPropertyNode*, <br />            "objectPropertyExpression", {} )<br />EDGE( *minimumCardinalityNode*, <br />            *classExpressionNode*, <br />            "classExpression", {} ) |
| ObjectMaxCardinality(`n` `OPE`)                              | ***maximumCardinalityNode*** = <br />   NODE( ["ObjectMaxCardinality", "ClassExpression"], { cardinality=`n` } )<br />*objectPropertyNode* = T(`OPE`)<br />EDGE( *maximumCardinalityNode*, <br />            *objectPropertyNode*, <br />            "objectPropertyExpression", {} ) |
| ObjectMaxCardinality(`n` `OPE` `CE`)                         | ***maximumCardinalityNode*** = <br />   NODE( ["ObjectMaxCardinality", "ClassExpression"], { cardinality=`n` } )<br />*objectPropertyNode* = T(`OPE`)<br />*classExpressionNode* = T(`CE`)<br />EDGE( *maximumCardinalityNode*, <br />            *objectPropertyNode*, <br />            "objectPropertyExpression", {} )<br />EDGE( *maximumCardinalityNode*, <br />            *classExpressionNode*, <br />            "classExpression", {} ) |
| ObjectExactCardinality(`n` `OPE`)                            | **exactCardinalityNode** = <br />   NODE( ["ObjectExactCardinality", "ClassExpression"], { cardinality=`n` } )<br />*objectPropertyNode* = T(`OPE`)<br />EDGE( *exactCardinalityNode*, <br />            *objectPropertyNode*, <br />            "objectPropertyExpression", {} ) |
| ObjectExactCardinality(`n` `OPE` `CE`)                       | ***exactCardinalityNode*** = <br />   NODE( ["ObjectExactCardinality", "ClassExpression"], { cardinality=`n` } )<br />*objectPropertyNode* = T(`OPE`)<br />*classExpressionNode* = T(`CE`)<br />EDGE( *exactCardinalityNode*, <br />            *objectPropertyNode*, <br />            "objectPropertyExpression", {} )<br />EDGE( *exactCardinalityNode*, <br />            *classExpressionNode*, <br />            "classExpression", {} ) |
| DataSomeValuesFrom(`DPE` `DR`)                               | ***existentialQuantifierNode*** = <br />   NODE( ["DataSomeValuesFrom", "ClassExpression"], {} )<br />*dataPropertyNode* = T(`DPE`)<br />*dataRangeNode* = T(`DR`)<br />EDGE( *existentialQuantifierNode*, <br />            *dataPropertyNode*, <br />            "dataPropertyExpression", {} )<br />EDGE( *existentialQuantifierNode*, <br />            *dataRangeNode*, <br />            "dataRange", {} ) |
| DataAllValuesFrom(`DPE` `DR`)                                | ***universalQuantifierNode*** = <br />   NODE( ["DataAllValuesFrom", "ClassExpression"], {} )<br />*dataPropertyNode* = T(`DPE`)<br />*dataRangeNode* = T(`DR`)<br />EDGE( *universalQuantifierNode*, <br />            *dataPropertyNode*, <br />            "dataPropertyExpression", {} )<br />EDGE( *universalQuantifierNode*, <br />            *dataRangeNode*, <br />            "dataRange", {} ) |
| DataHasValue(`DPE` `lt`)                                     | ***literalValueRestrictionNode*** = <br />   NODE( ["DataHasValue", "ClassExpression"], {} )<br />*dataPropertyNode* = T(`DPE`)<br />*literalNode* = T(`lt`)<br />EDGE( *literalValueRestrictionNode*, <br />            *dataPropertyNode*, <br />            "dataPropertyExpression", {} )<br />EDGE( *literalValueRestrictionNode*, <br />            *literalNode*, <br />            "literal", {} ) |
| DataMinCardinality(`n` `DPE`)                                | ***minimumCardinalityNode*** = <br />   NODE( ["DataMinCardinality", "ClassExpression"], { cardinality=`n` } )<br />*dataPropertyNode* = T(`DPE`)<br />EDGE( *minimumCardinalityNode*, <br />            *dataPropertyNode*, <br />            "dataPropertyExpression", {} ) |
| DataMinCardinality(`n` `DPE` `DR`)                           | ***minimumCardinalityNode*** = <br />   NODE( ["DataMinCardinality", "ClassExpression"], { cardinality=`n` } )<br />*dataPropertyNode* = T(`DPE`)<br />*dataRangeNode* = T(`DR`)<br />EDGE( *minimumCardinalityNode*, <br />            *dataPropertyNode*, <br />            "dataPropertyExpression", {} )<br />EDGE( *minimumCardinalityNode*, <br />            *dataRangeNode*, <br />            "dataRange", {} ) |
| DataMaxCardinality(`n` `DPE`)                                | ***maximumCardinalityNode*** = <br />   NODE( ["DataMaxCardinality", "ClassExpression"], { cardinality=`n` } )<br />*dataPropertyNode* = T(`DPE`)<br />EDGE( *maximumCardinalityNode*, <br />            *dataPropertyNode*, <br />            "dataPropertyExpression", {} ) |
| DataMaxCardinality(`n` `DPE` `DR`)                           | ***maximumCardinalityNode*** = <br />   NODE( ["DataMaxCardinality", "ClassExpression"], { cardinality=`n` } )<br />*dataPropertyNode* = T(`DPE`)<br />*dataRangeNode* = T(`DR`)<br />EDGE( *maximumCardinalityNode*, <br />            *dataPropertyNode*, <br />            "dataPropertyExpression", {} )<br />EDGE( *maximumCardinalityNode*, <br />            *dataRangeNode*, <br />            "dataRange", {} ) |
| DataExactCardinality(`n` `DPE`)                              | ***exactCardinalityNode*** = <br />   NODE( ["DataExactCardinality", "ClassExpression"], { cardinality=`n` } )<br />*dataPropertyNode* = T(`DPE`)<br />EDGE( *exactCardinalityNode*, <br />            *dataPropertyNode*, <br />            "dataPropertyExpression", {} ) |
| DataExactCardinality(`n` `DPE` `DR`)                         | ***exactCardinalityNode*** = <br />   NODE( ["DataExactCardinality", "ClassExpression"], { cardinality=`n` } )<br />*dataPropertyNode* = T(`DPE`)<br />*dataRangeNode* = T(`DR`)<br />EDGE( *exactCardinalityNode*, <br />            *dataPropertyNode*, <br />            "dataPropertyExpression", {} )<br />EDGE( *exactCardinalityNode*, <br />            *dataRangeNode*, <br />            "dataRange", {} ) |
| ObjectInverseOf(`OP`)                                        | ***inversePropertyNode*** = <br />   NODE( ["ObjectInverseOf", "ObjectPropertyExpression"], {} )<br />*objectPropertyNode* = T(`OP`)<br />EDGE( *inversePropertyNode*, <br />            *objectPropertyNode*, <br />            "objectProperty", {} ) |
| SubClassOf(`CE1` `CE2`)                                      | ***subclassAxiomNode*** = <br />   NODE( ["SubClassOf", "ClassAxiom", "Axiom"], {} )<br />*subClassExpressionNode* = T(`CE1`)<br />*superClassExpressionNode* = T(`CE2`)<br />EDGE( *subclassAxiomNode*, <br />            *subClassExpressionNode*, <br />            "subClassExpression", {} )<br />EDGE( *subclassAxiomNode*,<br />            *superClassExpressionNode*, <br />            "superClassExpression", {} ) |
| EquivalentClasses(`CE1` ... `CEn`)                           | ***equivalentClassesAxiomNode*** = <br />   NODE( ["EquivalentClasses", "ClassAxiom", "Axiom"], {} )<br />*classExpressionNodes* = T(`CE1` ... `CEn`)<br />EDGES( *equivalentClassesAxiomNode*, <br />              *classExpressionNodes*, <br />              "classExpression", {} ) |
| DisjointClasses(`CE1` ... `CEn`)                             | **disjointClassesAxiomNode** = <br />   NODE( ["DisjointClasses", "ClassAxiom", "Axiom"], {} )<br />*classExpressionNodes* = T(`CE1` ... `CEn`)<br />EDGES( *disjointClassesAxiomNode*, <br />              *classExpressionNodes*, <br />              "classExpression", {} ) |
| DisjointUnion(`C` `CE1` ... `CEn`)                           | ***disjointUnionAxiomNode*** = <br />   NODE( ["DisjointUnion", "ClassAxiom", "Axiom"], {} )<br />*classNode* = T(`C`)<br />*classExpressionNodes* = T(`CE1` ... `CEn`)<br />EDGE( *disjointUnionAxiomNode*, <br />            *classNode*, <br />            "class", {} )<br />EDGES( *disjointUnionAxiomNode*, <br />              *classExpressionNodes*, <br />              "disjointClassExpression", {} ) |
| SubObjectPropertyOf(`OPE1` `OPE2`)                           | ***subpropertiesAxiomNode*** = <br />   NODE( ["SubObjectPropertyOf", "ObjectPropertyAxiom", "Axiom"], {} )<br />*subPropertyExpressionNode* = T(`OPE1`)<br />*superPropertyExpressionNode* = T(`OPE2`)<br />EDGE( *subpropertiesAxiomNode*, <br />            *subPropertyExpressionNode*, <br />            "subObjectPropertyExpression", {} )<br />EDGE( *subpropertiesAxiomNode*, <br />            *superPropertyExpressionNode*, <br />            "superObjectPropertyExpression", {} ) |
| SubObjectPropertyOf(<br />   ObjectPropertyChain(`OPE1` ... `OPEn`)<br />   `OPE`) | ***subpropertiesAxiomNode*** = <br />   NODE( ["SubObjectPropertyOf", "ObjectPropertyAxiom", "Axiom"], {} )<br />*subPropertyExpressionNode* = T(`SEQ` `OPE1` ... `OPEn`)<br />*superPropertyExpressionNode* = T(`OPE`)<br />EDGE( *subpropertiesAxiomNode*,  <br />            *subPropertyExpressionNode*, <br />            "subObjectPropertyExpression", {} )<br />EDGE( *subpropertiesAxiomNode*, <br />            *superPropertyExpressionNode*, <br />            "superObjectPropertyExpression", {} ) |
| EquivalentObjectProperties(`OPE1` ... `OPEn`)                | ***equivalentPropertiesAxiomNode*** = <br />   NODE( ["EquivalentObjectProperties", "ObjectPropertyAxiom", "Axiom"], {} )<br />*objectPropertyExpressionNodes* = T(`OPE1` ... `OPEn`)<br />EDGES( *equivalentPropertiesAxiomNode*, <br />              *objectPropertyExpressionNodes*, <br />              "objectPropertyExpression", {} ) |
| DisjointObjectProperties(`OPE1` ... `OPEn`)                  | ***disjointPropertiesAxiomNode*** = <br />   NODE( ["DisjointObjectProperties", "ObjectPropertyAxiom", "Axiom"], {} )<br />*objectPropertyExpressionNodes* = T(`OPE1` ... `OPEn`)<br />EDGES( *disjointPropertiesAxiomNode*, <br />              *objectPropertyExpressionNodes*, <br />              "objectPropertyExpression", {} ) |
| ObjectPropertyDomain(`OPE` `CE`)                             | ***propertyDomainAxiomNode*** = <br />    NODE( ["ObjectPropertyDomain", "ObjectPropertyAxiom", "Axiom"], {} )<br />*objectPropertyExpressionNode* = T(`OPE`)<br />*classExpressionNode* = T(`CE`)<br />EDGE( *propertyDomainAxiomNode*, <br />            *objectPropertyExpressionNode*, <br />            "objectPropertyExpression", {} )<br />EDGE( *propertyDomainAxiomNode*, <br />            *classExpressionNode*, <br />            "domain", {} ) |
| ObjectPropertyRange(`OPE` `CE`)                              | ***propertyRangeAxiomNode*** = <br />   NODE( ["ObjectPropertyRange", "ObjectPropertyAxiom", "Axiom"], {} )<br />*objectPropertyExpressionNode* = T(`OPE`)<br />*classExpressionNode* = T(`CE`)<br />EDGE( *propertyRangeAxiomNode*, <br />            *objectPropertyExpressionNode*, <br />            "objectPropertyExpression", {} )<br />EDGE( *propertyRangeAxiomNode*, <br />            *classExpressionNode*, <br />            "range", {} ) |
| InverseObjectProperties(`OPE1` `OPE2`)                       | ***inversePropertiesAxiomNode*** = <br />   NODE( ["InverseObjectProperties", "ObjectPropertyAxiom", "Axiom"], {} )<br />*objectPropertyExpressionOneNode* = T(`OPE1`)<br />*objectPropertyExpressionTwoNode* = T(`OPE2`)<br />EDGE( *inversePropertiesAxiomNode*, <br />            *objectPropertyExpressionOneNode*, <br />            "objectPropertyExpression", {} )<br />EDGE( *inversePropertiesAxiomNode*, <br />            *objectPropertyExpressionTwoNode*, <br />            "objectPropertyExpression", {} ) |
| FunctionalObjectProperty(`OPE`)                              | ***functionalPropertyAxiomNode*** = <br />   NODE( ["FunctionalObjectProperty", "ObjectPropertyAxiom", "Axiom"], {} )<br />*objectPropertyExpressionNode* = T(`OPE`)<br />EDGE( *functionalPropertyAxiomNode*, <br />            *objectPropertyExpressionNode*, <br />            "objectPropertyExpression", {} ) |
| InverseFunctionalObjectProperty(`OPE`)                       | ***inverseFunctionalPropertyAxiomNode*** = <br />   NODE( ["InverseFunctionalObjectProperty", "ObjectPropertyAxiom", "Axiom"], {} )<br />*objectPropertyExpressionNode* = T(`OPE`)<br />EDGE( *inverseFunctionalPropertyAxiomNode*, <br />            *objectPropertyExpressionNode*, <br />            "objectPropertyExpression", {} ) |
| ReflexiveObjectProperty(`OPE`)                               | ***reflexivePropertyAxiomNode*** = <br />   NODE( ["ReflexiveObjectProperty", "ObjectPropertyAxiom", "Axiom"], {} )<br />*objectPropertyExpressionNode* = T(`OPE`)<br />EDGE( *reflexivePropertyAxiomNode*, <br />            *objectPropertyExpressionNode*, <br />            "objectPropertyExpression", {} ) |
| IrreflexiveObjectProperty(`OPE`)                             | ***irreflexivePropertyAxiomNode*** = <br />   NODE( ["IrreflexiveObjectProperty", "ObjectPropertyAxiom", "Axiom"], {} )<br />*objectPropertyExpressionNode* = T(`OPE`)<br />EDGE( *irreflexivePropertyAxiomNode*, <br />            *objectPropertyExpressionNode*, <br />            "objectPropertyExpression", {} ) |
| SymmetricObjectProperty(`OPE`)                               | ***symmetricPropertyAxiomNode*** = <br />   NODE( ["SymmetricObjectProperty", "ObjectPropertyAxiom", "Axiom"], {} )<br />*objectPropertyExpressionNode* = T(`OPE`)<br />EDGE( *symmetricPropertyAxiomNode*, <br />            *objectPropertyExpressionNode*, <br />            "objectPropertyExpression", {} ) |
| AsymmetricObjectProperty(`OPE`)                              | **asymmetricPropertyAxiomNode** = <br />   NODE( ["AsymmetricObjectProperty", "ObjectPropertyAxiom", "Axiom"], {} )<br />*objectPropertyExpressionNode* = T(`OPE`)<br />EDGE( *asymmetricPropertyAxiomNode*, <br />            *objectPropertyExpressionNode*, <br />            "objectPropertyExpression", {} ) |
| TransitiveObjectProperty(`OPE`)                              | ***transitivePropertyAxiomNode*** = <br />   NODE( ["TransitiveObjectProperty", "ObjectPropertyAxiom", "Axiom"], {} )<br />*objectPropertyExpressionNode* = T(`OPE`)<br />EDGE( *transitivePropertyAxiomNode*, <br />            *objectPropertyExpressionNode*, <br />            "objectPropertyExpression", {} ) |
| SubDataPropertyOf(`DPE1` `DPE2` )                            | ***subpropertiesAxiomNode*** = <br />   NODE( ["SubDataPropertyOf", "DataPropertyAxiom", "Axiom"], {} )<br />*subPropertyExpressionNode* = T(`DPE1`)<br />*superPropertyExpressionNode* = T(`DPE2`)<br />EDGE( *subpropertiesAxiomNode*, <br />            *subPropertyExpressionNode*, <br />            "subDataPropertyExpression", {} )<br />EDGE( *subpropertiesAxiomNode*, <br />            *superPropertyExpressionNode*, <br />            "superDataPropertyExpression", {} ) |
| EquivalentDataProperties(`DPE1`... `DPEn`)                   | ***equivalentPropertiesAxiomNode*** = <br />   NODE( ["EquivalentDataProperties", "DataPropertyAxiom", "Axiom"], {} )<br />*dataPropertyExpressionNodes* = T(`DPE1` ... `DPEn`)<br />EDGES( *equivalentPropertiesAxiomNode*, <br />              *dataPropertyExpressionNodes*, <br />              "dataPropertyExpression", {} ) |
| DisjointDataProperties(`DPE1`... `DPEn`)                     | ***disjointPropertiesAxiomNode*** = <br />   NODE( ["DisjointDataProperties", "DataPropertyAxiom", "Axiom"], {} )<br />*dataPropertyExpressionNodes* = T(`DPE1` ... `DPEn`)<br />EDGES( *disjointPropertiesAxiomNode*, <br />              *dataPropertyExpressionNodes*, <br />              "dataPropertyExpression", {} ) |
| DataPropertyDomain(`DPE` `CE`)                               | ***propertyDomainAxiomNode*** = <br />   NODE( ["DataPropertyDomain", "DataPropertyAxiom", "Axiom"], {} )<br />*dataPropertyExpressionNode* = T(`DPE`)<br />*classExpressionNode* = T(`CE`)<br />EDGE( *propertyDomainAxiomNode*, <br />            *dataPropertyExpressionNode*, <br />            "dataPropertyExpression", {} )<br />EDGE( *propertyDomainAxiomNode*, <br />            *classExpressionNode*, <br />            "domain", {} ) |
| DataPropertyRange(`DPE` `DR`)                                | ***propertyRangeAxiomNode*** = <br />   NODE( ["DataPropertyRange", "DataPropertyAxiom", "Axiom"], {} )<br />*dataPropertyExpressionNode* = T(`DPE`)<br />*dataRangeNode* = T(`DR`)<br />EDGE( *propertyRangeAxiomNode*, <br />            *dataPropertyExpressionNode*, <br />            "objectPropertyExpression", {} )<br />EDGE( *propertyRangeAxiomNode*, <br />            *dataRangeNode*, <br />            "range", {} ) |
| FunctionalDataProperty(`DPE`)                                | ***functionalPropertyAxiomNode*** = <br />   NODE( ["FunctionalDataProperty", "DataPropertyAxiom", "Axiom"], {} )<br />*dataPropertyExpressionNode* = T(`DPE`)<br />EDGE( *functionalPropertyAxiomNode*, <br />            *dataPropertyExpressionNode*, <br />            "dataPropertyExpression", {} ) |
| DatatypeDefinition(`DT` `DR`)                                | ***datatypeDefinitionAxiomNode*** = <br />   NODE( ["DatatypeDefintion", "Axiom"], {} )<br />*datatypeNode* = T(`DT`)<br />*dataRangeNode* = T(`DR`)<br />EDGE( *datatypeDefinitionAxiomNode*, <br />            *datatypeNode*, <br />            "datatype", {} )<br />EDGE( *datatypeDefinitionAxiomNode*, <br />            *dataRangeNode*, <br />            "dataRange", {} ) |
| HasKey(`CE` `(OPE1` ... `OPEm)` `(DPE1`... `DPEn)`)          | ***hasKeyAxiomNode*** = <br />   NODE( ["HasKey", "Axiom"], {} )<br />*classExpressionNode* = T(`CE`)<br />*objectPropertyExpressionNodes* = T(`OPE1` ... `OPEm`)<br />*dataPropertyExpressionNodes* = T(`DPE1` ... `DPEn`)<br />EDGE( *hasKeyAxiomNode*, <br />            *classExpressionNode*, <br />            "classExpression", {} )<br />EDGES( *hasKeyAxiomNode*, <br />              *objectPropertyExpressionNodes*, <br />              "objectPropertyExpression", {} )<br />EDGES( *hasKeyAxiomNode*, <br />              *dataPropertyExpressionNodes*, <br />              "dataPropertyExpression", {} ) |
| SameIndividual(`a1` ... `an`)                                | ***individualEqualityAxiomNode*** = <br />   NODE( ["SameIndividual", "Assertion", "Axiom"], {} )<br />*individualNodes* = T(`a1` ... `an`)<br />EDGES( *individualEqualityAxiomNode*, <br />              *individualNodes*, <br />              "individual", {} ) |
| DifferentIndividuals(`a1` ... `an`)                          | ***individualInequalityAxiomNode*** = <br />   NODE( ["DifferentIndividuals", "Assertion", "Axiom"], {} )<br />*individualNodes* = T(`a1` ... `an`)<br />EDGES( *individualInequalityAxiomNode*, <br />              *individualNodes*, <br />              "individual", {} ) |
| ClassAssertion(`CE` `a`)                                     | ***assertionAxiomNode*** = <br />   NODE( ["ClassAssertion", "Assertion", "Axiom"], {} )<br />*classExpressionNode* = T(`CE`)<br />*individualNode* = T(`a`)<br />EDGE( *assertionAxiomNode*, <br />            *classExpressionNode*, <br />            "classExpression", {} )<br />EDGE( *assertionAxiomNode*, <br />            *individualNode*, <br />            "individual", {} ) |
| ObjectPropertyAssertion(`OPE` `a1` `a2`)                     | ***assertionAxiomNode*** = <br />   NODE( ["ObjectPropertyAssertion", "Assertion", "Axiom"], {} )<br />*objectPropertyExpressionNode* = T(`OPE`)<br />*sourceIndividualNode* = T(`a1`)<br />*targetIndividualNode* = T(`a2`)<br />EDGE( *assertionAxiomNode*, <br />            *objectPropertyExpressionNode*, <br />            "objectPropertyExpression", {} )<br />EDGE( *assertionAxiomNode*, <br />            *sourceIndividualNode*, <br />            "sourceIndividual", {} )<br />EDGE( *assertionAxiomNode*, <br />            *targetIndividualNode*, <br />            "targetIndividual", {} ) |
| NegativeObjectPropertyAssertion(`OPE` `a1` `a2`)             | ***assertionAxiomNode*** = <br />   NODE( ["NegativeObjectPropertyAssertion", "Assertion", "Axiom"], {} )<br />*objectPropertyExpressionNode* = T(`OPE`)<br />*sourceIndividualNode* = T(`a1`)<br />*targetIndividualNode* = T(`a2`)<br />EDGE( *assertionAxiomNode*, <br />            *objectPropertyExpressionNode*, <br />            "objectPropertyExpression", {} )<br />EDGE( *assertionAxiomNode*, <br />            *sourceIndividualNode*, <br />            "sourceIndividual", {} )<br />EDGE( *assertionAxiomNode*, <br />            *targetIndividualNode*, <br />            "targetIndividual", {} ) |
| DataPropertyAssertion(`DPE` `a` `lt`)                        | ***assertionAxiomNode*** = <br />   NODE( ["DataPropertyAssertion", "Assertion", "Axiom"], {} )<br />*dataPropertyExpressionNode* = T(`DPE`)<br />*sourceIndividualNode* = T(`a`)<br />*targetLiteralNode* = T(`lt`)<br />EDGE( *assertionAxiomNode*, <br />            *dataPropertyExpressionNode*, <br />            "dataPropertyExpression", {} )<br />EDGE( *assertionAxiomNode*, <br />            *sourceIndividualNode*, <br />            "sourceIndividual", {} )<br />EDGE( *assertionAxiomNode*, <br />            *targetLiteralNode*, <br />            "targetValue", {} ) |
| NegativeDataPropertyAssertion(`DPE` `a` `lt`)                | ***assertionAxiomNode*** = <br />   NODE( ["NegativeDataPropertyAssertion", "Assertion", "Axiom"], {} )<br />*dataPropertyExpressionNode* = T(`DPE`)<br />*sourceIndividualNode* = T(`a`)<br />*targetLiteralNode* = T(`lt`)<br />EDGE( *assertionAxiomNode*, <br />            *dataPropertyExpressionNode*, <br />            "dataPropertyExpression", {} )<br />EDGE( *assertionAxiomNode*, <br />            *sourceIndividualNode*, <br />            "sourceIndividual", {} )<br />EDGE( *assertionAxiomNode*, <br />            *targetLiteralNode*, <br />            "targetValue", {} ) |
| AnnotationAssertion(`AP` `as` `av`)                          | ***assertionAxiomNode*** = <br />   NODE( ["AnnotationAssertion", "AnnotationAxiom", "Axiom"], {} )<br />*annotationPropertyNode* = T(`AP`)<br />*annotationSubjectNode* = T(`as`)<br />*annotationValueNode* = T(`av`)<br />EDGE( *assertionAxiomNode*, <br />            *annotationPropertyNode*, <br />            "annotationProperty", {} )<br />EDGE( *assertionAxiomNode*, <br />            *annotationSubjectNode*, <br />            "annotationSubject", {} )<br />EDGE( *assertionAxiomNode*, <br />            *annotationValueNode*, <br />            "annotationValue", {} ) |
| SubAnnotationPropertyOf(`AP1` `AP2`)                         | ***subpropertiesAxiomNode*** = <br />   NODE( ["SubAnnotationPropertyOf", "AnnotationAxiom", "Axiom"], {} )<br />*subAnnotationPropertyNode* = T(`AP1`)<br />*superAnnotationPropertyNode* = T(`AP2`)<br />EDGE( *subpropertiesAxiomNode*, <br />            *subAnnotationPropertyNode*, <br />            "subAnnotationProperty", {} )<br />EDGE( *subpropertiesAxiomNode*, <br />            *superAnnotationPropertyNode*, <br />            "superAnnotationProperty", {} ) |
| AnnotationPropertyDomain(`AP` `U`)                           | ***propertyDomainAxiomNode*** = <br />   NODE( ["AnnotationPropertyDomain", "AnnotationAxiom", "Axiom"], {} )<br />*annotationPropertyNode* = T(`AP`)<br />*iriNode* = T(`U`)<br />EDGE( *propertyDomainAxiomNode*, <br />            *annotationPropertyNode*, <br />            "annotationProperty", {} )<br />EDGE( *propertyDomainAxiomNode*, <br />            *iriNode*, <br />            "domain", {} ) |
| AnnotationPropertyRange(`AP` `U`)                            | ***propertyRangeAxiomNode*** = <br />   NODE( ["AnnotationPropertyRange", "AnnotationAxiom", "Axiom"], {} )<br />*annotationPropertyNode* = T(`AP`)<br />iriNode = T(`U`)<br />EDGE( *propertyRangeAxiomNode*, <br />            *annotationPropertyNode*, <br />            "annotationProperty", {} )<br />EDGE( *propertyRangeAxiomNode*, <br />            *iriNode*, <br />            "range", {} ) |



## Translation of Annotations

**Table 2**: Translation of Annotations

| Annotation A                                                 | Graph Generated in an Invocation of *TANN(A)*                |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `annotation1` ... `annotationn`                              | ***nodes*** = { n \| TANN(`annotation1`) ... TANN(`annotationn`) } |
| Annotation(`AP` `av`)                                        | ***annotationNode*** = NODE( ["Annotation"], {} )<br />*annotationPropertyNode* = T(`AP`)<br />*annotationValueNode* = T(`av`)<br />EDGE( *annotationNode*, <br />            *annotationPropertyNode*, <br />            "annotationProperty", {} )<br />EDGE( *annotationNode*, <br />            *annotationValueNode*, <br />            "annotationValue", {} ) |
| Annotation(<br />   `annotation1`  ...  `annotationn` <br />   `AP` `av`) | ***annotationNode*** = NODE( ["Annotation"], {} )<br />*annotationPropertyNode* = T(`AP`)<br />*annotationValueNode* = T(`av`)<br />*annotationAnnotationsNode* = TANN(`annotation` ... `annotationn`)<br />EDGES( *annotationNode*, <br />              *annotationAnnotationsNode*, <br />              "annotationAnnotation", {} )<br />EDGE( *annotationNode*, <br />            *annotationPropertyNode*, <br />            "annotationProperty", {} )<br />EDGE( *annotationNode*, <br />            *annotationValueNode*, <br />            "annotationValue", {} ) |

### Annotated Axioms

If an axiom `ax` contains embedded annotations `annotation1` ... `annotationm`, its translation into LPG depends on the type of the axiom. Use **Table 1** to translate the axiom and include the invocation of TANN(`annotation1` ... `annotatiom`) for translating the annotations, for example the SubClassOf axiom with annotations will generate a LPG graph as the following:

***subclassAxiomNode*** = NODE( ["SubClassOf", "ClassAxiom", "Axiom"], {} )<br />*subClassNode* = T(`CE1`)<br />*superClassNode* = T(`CE2`)<br />axiomAnnotationNodes = TANN(`annotation1` ... `annotationm`)<br />EDGE( *subclassAxiomNode*, *subClassNode*, "subClassExpression", {} )<br />EDGE( *subclassAxiomNode*, *superClassNode*, "superClassExpression", {} )<br />EDGES( *subclassAxiomNode*, *axiomAnnotationNodes*, "axiomAnnotation", {} )